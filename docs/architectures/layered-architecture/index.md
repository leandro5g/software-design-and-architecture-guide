# Layered Architecture (Arquitetura em Camadas) ‚õóÔ∏è

A **Layered Architecture**, ou Arquitetura em Camadas, √© uma das abordagens mais utilizadas para organizar sistemas de software. A ideia √© simples: dividir o sistema em **camadas**, cada uma com sua responsabilidade bem definida, e controlar como elas interagem.

Imagine isso como um hamb√∫rguer üçî: cada camada tem um papel claro (p√£o, carne, alface) e elas trabalham juntas para criar uma experi√™ncia funcional e organizada.

---

## Como funciona a arquitetura em camadas? üåê

A ideia √© separar as "preocupa√ß√µes" (ou responsabilidades) do sistema em diferentes n√≠veis. Cada camada tem uma fun√ß√£o clara e **s√≥ conversa diretamente** com as camadas mais pr√≥ximas. Vamos detalhar cada uma:

### Diagrama Contextual üìä

Este diagrama mostra como as camadas interagem:

```mermaid
graph TD
    UI[Camada de Apresenta√ß√£o]
    BL[Camada de L√≥gica de Neg√≥cio]
    DAL[Camada de Acesso a Dados]
    DB[(Banco de Dados)]

    UI --> BL
    BL --> DAL
    DAL --> DB
```

A comunica√ß√£o segue um fluxo hier√°rquico: a apresenta√ß√£o conversa com a l√≥gica de neg√≥cio, que interage com o acesso a dados, que por sua vez acessa o banco.

### Camada de Apresenta√ß√£o (Presentation Layer) üìù

Essa √© a "cara" da sua aplica√ß√£o ‚Äî o que o usu√°rio v√™ e interage. O foco aqui √© capturar as entradas do usu√°rio e exibir os dados de forma clara e amig√°vel. Essa camada √© composta por **telas**, **componentes de interface** ou **elementos do front-end** que representam a intera√ß√£o com o sistema.

- **Responsabilidades principais:**

  - Renderizar os dados que v√™m das camadas inferiores.
  - Capturar entradas do usu√°rio e validar informa√ß√µes b√°sicas antes de envi√°-las para as camadas inferiores.
  - Exibir mensagens de erro ou de sucesso.

- **Exemplos no mundo real:**

  - Uma p√°gina da web constru√≠da com React ou Angular.
  - Um componente visual ou tela espec√≠fica em um aplicativo m√≥vel desenvolvido com Flutter ou React Native.
  - No backend, pode ser um endpoint que recebe dados HTTP e retorna respostas JSON.

> üí° *Evite misturar responsabilidades nesta camada. No backend, n√£o insira regras de neg√≥cio ou acessos diretos ao banco de dados; j√° no front-end, mantenha o foco na renderiza√ß√£o de dados e captura de entradas.*

### Camada de L√≥gica de Neg√≥cio (Business Logic Layer) üß©

Aqui √© onde a "m√°gica" acontece. Essa √© a camada respons√°vel pelas regras e opera√ß√µes espec√≠ficas do sistema. Ela garante que os dados estejam corretos, que os processos sigam os requisitos e que os resultados sejam coerentes.

- **Responsabilidades principais:**

  - Processar os dados recebidos da camada de apresenta√ß√£o.
  - Aplicar regras de neg√≥cio, como descontos, valida√ß√µes complexas ou autoriza√ß√µes.
  - Interagir com a camada de acesso a dados para buscar ou armazenar informa√ß√µes necess√°rias.

- **Exemplos no mundo real:**

  - Verificar se um usu√°rio tem permiss√£o para acessar determinado recurso.
  - Calcular fretes com base no peso, dimens√µes e localiza√ß√£o do cliente.
  - Em um sistema backend, seria uma fun√ß√£o ou servi√ßo que processa pedidos e atualiza o estoque.

> ‚úÖ *Essa camada deve ser independente de tecnologias espec√≠ficas, como frameworks ou bancos de dados.*

### Camada de Acesso a Dados (Data Access Layer) üîé

Essa camada √© o "mensageiro" entre a aplica√ß√£o e o mundo externo (bancos de dados, APIs, etc.). Ela existe para centralizar e organizar todas as intera√ß√µes externas, deixando as outras camadas menos acopladas.

- **Responsabilidades principais:**

  - Executar opera√ß√µes de consulta, inser√ß√£o, atualiza√ß√£o e remo√ß√£o de dados.
  - Abstrair a complexidade de comunica√ß√£o com APIs externas ou fontes de dados.
  - Garantir que os dados estejam no formato correto para serem utilizados pela camada de neg√≥cio.

- **Exemplos no mundo real:**

  - Um reposit√≥rio em Node.js que realiza consultas SQL com uma biblioteca como Sequelize ou Knex.
  - Integra√ß√£o com APIs REST usando Axios ou Fetch.
  - Fun√ß√µes espec√≠ficas para interagir com bancos de dados, como MongoDB, PostgreSQL ou Redis.

> üîó *Manter essa camada desacoplada facilita migra√ß√µes futuras para novas tecnologias ou fontes de dados.*

---

## Exemplo no Front-end com React üåê

### Diagrama de Comunica√ß√£o no Front-end

```mermaid
graph TD
    UI[Componentes React (UI)]
    BL[Servi√ßos de L√≥gica (Hooks/Contextos)]
    DAL[Cliente HTTP (Axios/Fetch)]
    API[(API Backend)]

    UI --> BL
    BL --> DAL
    DAL --> API
```

### C√≥digo Exemplo

#### Camada de Acesso a Dados (API Client)

```javascript
// taskApi.js
import axios from 'axios';

const API_BASE_URL = 'https://api.exemplo.com/tasks';

export const getTasks = async () => {
  const response = await axios.get(API_BASE_URL);
  return response.data;
};

export const createTask = async (task) => {
  const response = await axios.post(API_BASE_URL, task);
  return response.data;
};
```

#### Camada de L√≥gica de Neg√≥cio (Servi√ßo)

```javascript
// taskService.js
import { getTasks, createTask } from './taskApi';

export const fetchTasks = async () => {
  const tasks = await getTasks();
  return tasks.filter((task) => !task.completed); // Retorna apenas tarefas n√£o conclu√≠das
};

export const addTask = async (task) => {
  if (!task.title) {
    throw new Error('O t√≠tulo da tarefa √© obrigat√≥rio!');
  }
  return await createTask(task);
};
```

#### Camada de Apresenta√ß√£o (Componente React)

```javascript
// TaskList.jsx
import React, { useEffect, useState } from 'react';
import { fetchTasks, addTask } from './taskService';

const TaskList = () => {
  const [tasks, setTasks] = useState([]);
  const [newTaskTitle, setNewTaskTitle] = useState('');

  useEffect(() => {
    const loadTasks = async () => {
      try {
        const tasks = await fetchTasks();
        setTasks(tasks);
      } catch (error) {
        console.error('Erro ao carregar tarefas:', error);
      }
    };
    loadTasks();
  }, []);

  const handleAddTask = async () => {
    try {
      const newTask = await addTask({ title: newTaskTitle });
      setTasks((prevTasks) => [...prevTasks, newTask]);
      setNewTaskTitle('');
    } catch (error) {
      console.error('Erro ao adicionar tarefa:', error);
    }
  };

  return (
    <div>
      <h1>Lista de Tarefas</h1>
      <ul>
        {tasks.map((task) => (
          <li key={task.id}>{task.title}</li>
        ))}
      </ul>
      <input
        type="text"
        value={newTaskTitle}
        onChange={(e) => setNewTaskTitle(e.target.value)}
      />
      <button onClick={handleAddTask}>Adicionar Tarefa</button>
    </div>
  );
};

export default TaskList;
```

---

## Exemplo no Backend com Node.js üåê

### Diagrama de Comunica√ß√£o no Backend

```mermaid
graph TD
    UI[Camada de Rota]
    BL[Servi√ßo de L√≥gica de Neg√≥cio]
    DAL[Reposit√≥rio de Dados]
    DB[(Banco de Dados)]

    UI --> BL
    BL --> DAL
    DAL --> DB
```

### C√≥digo Exemplo

#### Camada de Acesso a Dados (Reposit√≥rio)

```javascript
// userRepository.js
class UserRepository {
  constructor(database) {
    this.database = database;
  }

  async findByEmail(email) {
    const result = await this.database.query('SELECT * FROM users WHERE email = ?', [email]);
    return result[0] || null;
  }

  async save(user) {
    const result = await this.database.query('INSERT INTO users SET ?', user);
    return { id: result.insertId, ...user };
  }
}
module.exports = UserRepository;
```

#### Camada de L√≥gica de Neg√≥cio (Servi√ßo)

```javascript
// userService.js
const bcrypt = require('bcrypt');

class UserService {
  constructor(userRepository) {
    this.userRepository = userRepository;
  }

  async registerUser({ name, email, password }) {
    if (!email.includes('@')) {
      throw new Error('E-mail inv√°lido!');
    }

    const existingUser = await this.userRepository.findByEmail(email);
    if (existingUser) {
      throw new Error('Usu√°rio j√° cadastrado!');
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = await this.userRepository.save({ name, email, password: hashedPassword });

    return { id: newUser.id, name: newUser.name, email: newUser.email };
  }
}
module.exports = UserService;
```

#### Camada de Apresenta√ß√£o (Rota)

```javascript
// userRoutes.js
const express = require('express');
const router = express.Router();
const UserRepository = require('./userRepository');
const UserService = require('./userService');
const database = require('./database');

const userRepository = new UserRepository(database);
const userService = new UserService(userRepository);

router.post('/register', async (req, res) => {
  try {
    const user = await userService.registerUser(req.body);
    res.status(201).json(user);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

module.exports = router;
```

---

## Boas Pr√°ticas e Cuidados a Tomar üõ†Ô∏è

### Boas Pr√°ticas
1. **Separa√ß√£o Clara de Responsabilidades:** Certifique-se de que cada camada fa√ßa apenas o que lhe compete.
2. **Testabilidade:** Estruture as camadas para que possam ser testadas de forma independente.
3. **Abstra√ß√£o:** Use interfaces ou contratos claros para a comunica√ß√£o entre camadas.

### Cuidados
1. **Evite Acoplamento Excessivo:** N√£o permita que uma camada dependa diretamente da implementa√ß√£o de outra.
2. **Desempenho:** Certifique-se de que o fluxo de dados entre as camadas seja eficiente, especialmente em sistemas de alta performance.
3. **Complexidade Desnecess√°ria:** Para projetos simples, evite criar camadas demais, pois isso pode introduzir complexidade sem benef√≠cios.

---

## Conclus√£o üéØ

A arquitetura em camadas √© uma abordagem confi√°vel e flex√≠vel, ideal para sistemas que priorizam organiza√ß√£o e manuten√ß√£o. Com a separa√ß√£o clara de responsabilidades e boas pr√°ticas, voc√™ pode construir aplica√ß√µes robustas e escal√°veis que atendem tanto √†s demandas do presente quanto √†s do futuro! üöÄ
